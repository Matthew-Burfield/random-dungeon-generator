{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap ceecb58ce94d52f048f6","webpack:///./src/index.js"],"names":["VERTICAL","HORIZONTAL","randomIndexBetweenValues","min","max","Math","floor","random","randomDirection","directionOptions","length","numOptions","AddRoomBoundaries","array","currHeight","currWidth","map","row","rIndex","col","cIndex","NewDungeon","width","height","minRoomSize","maxRoomSize","Dungeon","init","counter","tree","level","Array","apply","split","connectRooms","setMinRoomSize","num","Error","setMaxRoomSize","node","splitDirection","getSplitOptions","indexToSplit","getIndexToSplit","lNode","leftNode","rNode","rightNode","splitIndex","slice","verticalLength","horizontalLength","push","vIndex","corridorIndex","hIndex","reduce","obj","val","index","temp","dungeon","Object","create","window"],"mappings":"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","file":"index.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"random-dungeon-generator\"] = factory();\n\telse\n\t\troot[\"random-dungeon-generator\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ceecb58ce94d52f048f6","const VERTICAL = 'VERTICAL'\nconst HORIZONTAL = 'HORIZONTAL'\n\n/**\n * Returns a random number between min and max\n *\n * @param {number} min minimum random number to return\n * @param {number} max maximum random number to return\n * @returns {number}\n */\nfunction randomIndexBetweenValues(min, max) {\n  return Math.floor((Math.random() * ((max - min) + 1)) + min)\n}\n\n/**\n * Return a random direction of vertical or horizontal\n *\n * @returns {string} 'vertical' or 'horizontal'\n */\nfunction randomDirection(directionOptions = [VERTICAL, HORIZONTAL]) {\n  if (directionOptions.length === 0) {\n    return ''\n  }\n\n  const numOptions = directionOptions.length - 1\n  return directionOptions[randomIndexBetweenValues(0, numOptions)]\n}\n\n/**\n * Add blocking tiles around the parameter of the 2d array\n *\n * @param {array} array 2d array representing a room\n */\nfunction AddRoomBoundaries(array) {\n  const currHeight = array.length - 1\n  const currWidth = array[0].length - 1\n  return array.map((row, rIndex) =>\n    row.map((col, cIndex) => {\n      if (rIndex === 0 || rIndex === currHeight || cIndex === 0 || cIndex === currWidth) {\n        return 1\n      }\n      return col\n    }),\n  )\n}\n\n/**\n * Function used to create a new dungeon object\n *\n * @param {number} [width=50]\n * @param {number} [height=50]\n * @param {number} [minRoomSize=5]\n * @param {number} [maxRoomSize=20]\n * @returns dungeon object\n */\nconst NewDungeon = function NewDungeon(\n  { width = 50, height = 50, minRoomSize = 5, maxRoomSize = 20 },\n) {\n  const Dungeon = {\n\n    init(width, height, minRoomSize, maxRoomSize) {\n      // Create an empty 2D array width x height\n      this.minRoomSize = 5\n      this.maxRoomSize = 20\n      this.counter = 1\n\n      // What am I trying to do here?\n      this.tree = {\n        level: Array.apply(null, { length: height }).map(() => (\n          Array.apply(null, { length: width })),\n        ),\n      }\n      this.split(this.tree)\n      this.connectRooms(this.tree)\n    },\n\n\n    setMinRoomSize(num) {\n      if (num > this.maxRoomSize) {\n        throw new Error(`Minimum room size cannot be larger than the maximum room size of ${this.maxRoomSize}`)\n      }\n      this.minRoomSize = num\n    },\n\n\n    setMaxRoomSize(num) {\n      if (num < this.minRoomSize) {\n        throw new Error(`Maximum room size cannot be smaller than the minimum room size of ${this.minRoomSize}`)\n      }\n      this.minRoomSize = num\n    },\n\n\n    /**\n     * Given a 2d array (node.level), this function will split the room into two separate arrays\n     * and store then in node.lNode.level and node.rNode.level.\n     * The split is random (vertical or horizontal)\n     * and can be anywhere along the axis as long as it doesn't result in making the room smaller\n     * than this.min.\n     *\n     * @param {object} node\n     */\n    split(node) {\n      if (node.level.length > this.maxRoomSize || node.level[0].length > this.maxRoomSize) {\n        // If this condition is true, then we need to split again\n\n        const splitDirection = randomDirection(\n          this.getSplitOptions(node.level.length, node.level[0].length),\n        )\n        const indexToSplit = this.getIndexToSplit(\n          splitDirection, node.level[0].length, node.level.length,\n        )\n\n        let lNode = node.leftNode = {}\n        let rNode = node.rightNode = {}\n        node.splitDirection = splitDirection\n        node.splitIndex = indexToSplit\n\n        /**\n         * Split the rooms either vertically or horizontally and store the\n         * new array in the left node and right nodes\n         */\n        if (splitDirection === VERTICAL) {\n          lNode.level = node.level.map(row => row.slice(0, indexToSplit))\n          rNode.level = node.level.map(row => row.slice(indexToSplit, row.length))\n        } else {\n          lNode.level = node.level.slice(0, indexToSplit)\n          rNode.level = node.level.slice(indexToSplit, node.level.length)\n        }\n\n        /**\n         * Recursive call to split the rooms again if needed\n         */\n        this.split(lNode)\n        this.split(rNode)\n      } else {\n        /**\n         * If we reach this point, then we can guarantee that the room does not\n         * have any children nodes. I.e. it's the smallest leaf node\n         * counter is used so we can visually see the different rooms when the room is rendered\n         */\n        this.counter += 1\n        node.level = node.level.map(row => row.map(() => this.counter))\n        node.level = AddRoomBoundaries(node.level)\n      }\n    },\n\n    /**\n     * returns an array with the values VERTICAL if a vertical split is an option, and\n     * HORIZONTAL is a horizontal split is an option, or an empy array neither are options.\n     * Whether or not it is an option is based on if the size of the room is greater than\n     * the maximum allowed room size.\n     *\n     * @param {number} verticalLength\n     * @param {number} horizontalLength\n     * @returns {array}\n     */\n    getSplitOptions(verticalLength, horizontalLength) {\n      const directionOptions = []\n      if (verticalLength > this.maxRoomSize) {\n        directionOptions.push(HORIZONTAL)\n      }\n      if (horizontalLength > this.maxRoomSize) {\n        directionOptions.push(VERTICAL)\n      }\n      return directionOptions\n    },\n\n\n    /**\n     * Returns a random number along the vertical or horizontal axis\n     *\n     * @param {any} verticalLength\n     * @param {any} horizontalLength\n     * @returns {number}\n     */\n    getIndexToSplit(splitDirection, horizontalLength, verticalLength) {\n      const min = this.minRoomSize\n      const max = splitDirection === VERTICAL ? horizontalLength - min : verticalLength - min\n      return randomIndexBetweenValues(min, max)\n    },\n\n\n    /**\n     * @param {any} node\n     * @returns\n     */\n    connectRooms(node) {\n      /**\n       * First, recursively loop through all the rooms so we're starting at the\n       * lowest nodes in the tree that have child nodes, and we work our way back up.\n       */\n      if (node.leftNode) {\n        this.connectRooms(node.leftNode)\n      } else {\n        return\n      }\n\n      if (node.rightNode) {\n        this.connectRooms(node.rightNode)\n      } else {\n        return\n      }\n\n      const lNode = node.leftNode.level\n      const rNode = node.rightNode.level\n\n\n      /**\n       * Since this function is called after all the rooms have been created, we know that all\n       * the rooms already have boundaries. We just need to remove the wall at a random\n       * intersecting point.\n       */\n      if (node.splitDirection === VERTICAL) {\n        /**\n         * For vertical cut, the corridor will be horizontal.\n         * So somewhere along the 0 -> firstRoom.length axis\n         * Don't put the corridor on the outer most index values (0 and length - 1) because\n         * that can allow the corridor to be on the map boundary\n         */\n        const vIndex = randomIndexBetweenValues(1, lNode.length - 2)\n        node.corridorIndex = vIndex\n        lNode[vIndex][lNode[0].length - 1] = 0\n        lNode[vIndex][lNode[0].length - 2] = 0\n        rNode[vIndex][0] = 0\n        rNode[vIndex][1] = 0\n      } else {\n      // For horizontal cut, the corridor will be vertical.\n      // So somewhere along the firstRoom[row[0]] -> firstRoom[row.length] axis\n        const hIndex = randomIndexBetweenValues(1, lNode[0].length - 2)\n        node.corridorIndex = hIndex\n        lNode[lNode.length - 1][hIndex] = 0\n        lNode[lNode.length - 2][hIndex] = 0\n        rNode[0][hIndex] = 0\n        rNode[1][hIndex] = 0\n      }\n\n      /**\n       * Combine the child left node and right node rooms back together, and\n       * save the result in the current level node.\n       */\n      node.level = []\n      if (node.splitDirection === VERTICAL) {\n        node.level = lNode.reduce((obj, val, index) => {\n          const temp = []\n          temp.push(...lNode[index])\n          temp.push(...rNode[index])\n          obj.push(temp)\n          return obj\n        }, [])\n      } else {\n        // If we get to this point, then the slice was horizontal\n        node.level.push(...lNode)\n        node.level.push(...rNode)\n      }\n    },\n  }\n\n\n  // /**\n  //  * 50% chance of returning a 0\n  //  * 50% chance of returning a 1\n  //  *\n  //  * @returns {number} 0 or 1\n  //  */\n  // function fiftyfifty() {\n  //   return randomIndexBetweenValues(0, 1)\n  // }\n\n  const dungeon = Object.create(Dungeon)\n  dungeon.init(width, height, minRoomSize, maxRoomSize)\n  return dungeon.tree.level\n} // end NewDungeon\n\nif (window) window.NewDungeon = NewDungeon\nexport default NewDungeon\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}