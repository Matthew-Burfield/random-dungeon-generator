{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.umd.min.js","webpack:///webpack/bootstrap 1bce244586403903e4f1","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_toConsumableArray","arr","Array","isArray","arr2","length","from","randomIndexBetweenValues","min","max","Math","floor","random","randomDirection","directionOptions","arguments","undefined","VERTICAL","HORIZONTAL","AddRoomBoundaries","array","currHeight","currWidth","map","row","rIndex","col","cIndex","value","NewDungeon","_ref","_ref$width","width","_ref$height","height","_ref$minRoomSize","minRoomSize","_ref$maxRoomSize","maxRoomSize","Dungeon","init","counter","tree","level","apply","split","connectRooms","setMinRoomSize","num","Error","setMaxRoomSize","node","_this","splitDirection","getSplitOptions","indexToSplit","getIndexToSplit","lNode","leftNode","rNode","rightNode","splitIndex","slice","verticalLength","horizontalLength","push","vIndex","corridorIndex","hIndex","reduce","obj","val","index","temp","_node$level","_node$level2","dungeon","create","window","default"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,4BAAAD,IAEAD,EAAA,4BAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,WAUA,OANAK,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KA4DA,OAhCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAtB,GACA,GAAAe,GAAAf,KAAAuB,WACA,WAA2B,MAAAvB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAK,GAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,GAGAvB,IAAAwB,EAAA,KDgBM,SAAU7B,EAAQD,EAASM,GAEjC,YAOA,SAASyB,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIvB,GAAI,EAAG0B,EAAOF,MAAMD,EAAII,QAAS3B,EAAIuB,EAAII,OAAQ3B,IAAO0B,EAAK1B,GAAKuB,EAAIvB,EAAM,OAAO0B,GAAe,MAAOF,OAAMI,KAAKL,GE5E1L,QAASM,GAAyBC,EAAKC,GACrC,MAAOC,MAAKC,MAAOD,KAAKE,UAAaH,EAAMD,EAAO,GAAMA,GAQ1D,QAASK,KAA2D,GAA3CC,GAA2CC,UAAAV,OAAA,OAAAW,KAAAD,UAAA,GAAAA,UAAA,IAAvBE,EAAUC,EACrD,OAAgC,KAA5BJ,EAAiBT,OACZ,GAIFS,EAAiBP,EAAyB,EAD9BO,EAAiBT,OAAS,IAS/C,QAASc,GAAkBC,GACzB,GAAMC,GAAaD,EAAMf,OAAS,EAC5BiB,EAAYF,EAAM,GAAGf,OAAS,CACpC,OAAOe,GAAMG,IAAI,SAACC,EAAKC,GAAN,MACfD,GAAID,IAAI,SAACG,EAAKC,GACZ,MAAe,KAAXF,GAAgBA,IAAWJ,GAAyB,IAAXM,GAAgBA,IAAWL,EAC/D,EAEFI,MFyCbvC,OAAOC,eAAenB,EAAS,cAC7B2D,OAAO,GEnFT,IAAMX,GAAW,WACXC,EAAa,aAsDbW,EAAa,SAAAC,GAEjB,GAAAC,GAAAD,EADEE,YACFhB,KAAAe,EADU,GACVA,EAAAE,EAAAH,EADcI,aACdlB,KAAAiB,EADuB,GACvBA,EAAAE,EAAAL,EAD2BM,kBAC3BpB,KAAAmB,EADyC,EACzCA,EAAAE,EAAAP,EAD4CQ,kBAC5CtB,KAAAqB,EAD0D,GAC1DA,EACME,GAEJC,KAFc,SAETR,EAAOE,EAAQE,EAAaE,GAE/BjE,KAAK+D,YAAc,EACnB/D,KAAKiE,YAAc,GACnBjE,KAAKoE,QAAU,EAGfpE,KAAKqE,MACHC,MAAOzC,MAAM0C,MAAM,MAAQvC,OAAQ6B,IAAUX,IAAI,iBAC/CrB,OAAM0C,MAAM,MAAQvC,OAAQ2B,OAGhC3D,KAAKwE,MAAMxE,KAAKqE,MAChBrE,KAAKyE,aAAazE,KAAKqE,OAIzBK,eAnBc,SAmBCC,GACb,GAAIA,EAAM3E,KAAKiE,YACb,KAAM,IAAIW,OAAJ,oEAA8E5E,KAAKiE,YAE3FjE,MAAK+D,YAAcY,GAIrBE,eA3Bc,SA2BCF,GACb,GAAIA,EAAM3E,KAAK+D,YACb,KAAM,IAAIa,OAAJ,qEAA+E5E,KAAK+D,YAE5F/D,MAAK+D,YAAcY,GAarBH,MA5Cc,SA4CRM,GAAM,GAAAC,GAAA/E,IACV,IAAI8E,EAAKR,MAAMtC,OAAShC,KAAKiE,aAAea,EAAKR,MAAM,GAAGtC,OAAShC,KAAKiE,YAAa,CAGnF,GAAMe,GAAiBxC,EACrBxC,KAAKiF,gBAAgBH,EAAKR,MAAMtC,OAAQ8C,EAAKR,MAAM,GAAGtC,SAElDkD,EAAelF,KAAKmF,gBACxBH,EAAgBF,EAAKR,MAAM,GAAGtC,OAAQ8C,EAAKR,MAAMtC,QAG/CoD,EAAQN,EAAKO,YACbC,EAAQR,EAAKS,YACjBT,GAAKE,eAAiBA,EACtBF,EAAKU,WAAaN,EAMdF,IAAmBpC,GACrBwC,EAAMd,MAAQQ,EAAKR,MAAMpB,IAAI,SAAAC,GAAA,MAAOA,GAAIsC,MAAM,EAAGP,KACjDI,EAAMhB,MAAQQ,EAAKR,MAAMpB,IAAI,SAAAC,GAAA,MAAOA,GAAIsC,MAAMP,EAAc/B,EAAInB,YAEhEoD,EAAMd,MAAQQ,EAAKR,MAAMmB,MAAM,EAAGP,GAClCI,EAAMhB,MAAQQ,EAAKR,MAAMmB,MAAMP,EAAcJ,EAAKR,MAAMtC,SAM1DhC,KAAKwE,MAAMY,GACXpF,KAAKwE,MAAMc,OAOXtF,MAAKoE,SAAW,EAChBU,EAAKR,MAAQQ,EAAKR,MAAMpB,IAAI,SAAAC,GAAA,MAAOA,GAAID,IAAI,iBAAM6B,GAAKX,YACtDU,EAAKR,MAAQxB,EAAkBgC,EAAKR,QAcxCW,gBAnGc,SAmGES,EAAgBC,GAC9B,GAAMlD,KAON,OANIiD,GAAiB1F,KAAKiE,aACxBxB,EAAiBmD,KAAK/C,GAEpB8C,EAAmB3F,KAAKiE,aAC1BxB,EAAiBmD,KAAKhD,GAEjBH,GAWT0C,gBAtHc,SAsHEH,EAAgBW,EAAkBD,GAChD,GAAMvD,GAAMnC,KAAK+D,WAEjB,OAAO7B,GAAyBC,EADpB6C,IAAmBpC,EAAW+C,EAAmBxD,EAAMuD,EAAiBvD,IAStFsC,aAjIc,SAiIDK,GAKX,GAAIA,EAAKO,WACPrF,KAAKyE,aAAaK,EAAKO,UAKrBP,EAAKS,WAAT,CACEvF,KAAKyE,aAAaK,EAAKS,UAKzB,IAAMH,GAAQN,EAAKO,SAASf,MACtBgB,EAAQR,EAAKS,UAAUjB,KAQ7B,IAAIQ,EAAKE,iBAAmBpC,EAAU,CAOpC,GAAMiD,GAAS3D,EAAyB,EAAGkD,EAAMpD,OAAS,EAC1D8C,GAAKgB,cAAgBD,EACrBT,EAAMS,GAAQT,EAAM,GAAGpD,OAAS,GAAK,EACrCoD,EAAMS,GAAQT,EAAM,GAAGpD,OAAS,GAAK,EACrCsD,EAAMO,GAAQ,GAAK,EACnBP,EAAMO,GAAQ,GAAK,MACd,CAGL,GAAME,GAAS7D,EAAyB,EAAGkD,EAAM,GAAGpD,OAAS,EAC7D8C,GAAKgB,cAAgBC,EACrBX,EAAMA,EAAMpD,OAAS,GAAG+D,GAAU,EAClCX,EAAMA,EAAMpD,OAAS,GAAG+D,GAAU,EAClCT,EAAM,GAAGS,GAAU,EACnBT,EAAM,GAAGS,GAAU,EAQrB,GADAjB,EAAKR,SACDQ,EAAKE,iBAAmBpC,EAC1BkC,EAAKR,MAAQc,EAAMY,OAAO,SAACC,EAAKC,EAAKC,GACnC,GAAMC,KAIN,OAHAA,GAAKR,KAALrB,MAAA6B,EAAAzE,EAAayD,EAAMe,KACnBC,EAAKR,KAALrB,MAAA6B,EAAAzE,EAAa2D,EAAMa,KACnBF,EAAIL,KAAKQ,GACFH,WAEJ,IAAAI,GAAAC,GAELD,EAAAvB,EAAKR,OAAMsB,KAAXrB,MAAA8B,EAAA1E,EAAmByD,KACnBkB,EAAAxB,EAAKR,OAAMsB,KAAXrB,MAAA+B,EAAA3E,EAAmB2D,QAgBnBiB,EAAUzF,OAAO0F,OAAOtC,EAE9B,OADAqC,GAAQpC,KAAKR,EAAOE,EAAQE,EAAaE,GAClCsC,EAAQlC,KAAKC,MAGlBmC,UAAQA,OAAOjD,WAAaA,GFoGhC5D,EAAQ8G,QEnGOlD","file":"index.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"random-dungeon-generator\"] = factory();\n\telse\n\t\troot[\"random-dungeon-generator\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"random-dungeon-generator\"] = factory();\n\telse\n\t\troot[\"random-dungeon-generator\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar VERTICAL = 'VERTICAL';\nvar HORIZONTAL = 'HORIZONTAL';\n\n/**\n * Returns a random number between min and max\n *\n * @param {number} min minimum random number to return\n * @param {number} max maximum random number to return\n * @returns {number}\n */\nfunction randomIndexBetweenValues(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Return a random direction of vertical or horizontal\n *\n * @returns {string} 'vertical' or 'horizontal'\n */\nfunction randomDirection() {\n  var directionOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [VERTICAL, HORIZONTAL];\n\n  if (directionOptions.length === 0) {\n    return '';\n  }\n\n  var numOptions = directionOptions.length - 1;\n  return directionOptions[randomIndexBetweenValues(0, numOptions)];\n}\n\n/**\n * Add blocking tiles around the parameter of the 2d array\n *\n * @param {array} array 2d array representing a room\n */\nfunction AddRoomBoundaries(array) {\n  var currHeight = array.length - 1;\n  var currWidth = array[0].length - 1;\n  return array.map(function (row, rIndex) {\n    return row.map(function (col, cIndex) {\n      if (rIndex === 0 || rIndex === currHeight || cIndex === 0 || cIndex === currWidth) {\n        return 1;\n      }\n      return col;\n    });\n  });\n}\n\n/**\n * Function used to create a new dungeon object\n *\n * @param {number} [width=50]\n * @param {number} [height=50]\n * @param {number} [minRoomSize=5]\n * @param {number} [maxRoomSize=20]\n * @returns dungeon object\n */\nvar NewDungeon = function NewDungeon(_ref) {\n  var _ref$width = _ref.width,\n      width = _ref$width === undefined ? 50 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === undefined ? 50 : _ref$height,\n      _ref$minRoomSize = _ref.minRoomSize,\n      minRoomSize = _ref$minRoomSize === undefined ? 5 : _ref$minRoomSize,\n      _ref$maxRoomSize = _ref.maxRoomSize,\n      maxRoomSize = _ref$maxRoomSize === undefined ? 20 : _ref$maxRoomSize;\n\n  var Dungeon = {\n    init: function init(width, height, minRoomSize, maxRoomSize) {\n      // Create an empty 2D array width x height\n      this.minRoomSize = 5;\n      this.maxRoomSize = 20;\n      this.counter = 1;\n\n      // What am I trying to do here?\n      this.tree = {\n        level: Array.apply(null, { length: height }).map(function () {\n          return Array.apply(null, { length: width });\n        })\n      };\n      this.split(this.tree);\n      this.connectRooms(this.tree);\n    },\n    setMinRoomSize: function setMinRoomSize(num) {\n      if (num > this.maxRoomSize) {\n        throw new Error('Minimum room size cannot be larger than the maximum room size of ' + this.maxRoomSize);\n      }\n      this.minRoomSize = num;\n    },\n    setMaxRoomSize: function setMaxRoomSize(num) {\n      if (num < this.minRoomSize) {\n        throw new Error('Maximum room size cannot be smaller than the minimum room size of ' + this.minRoomSize);\n      }\n      this.minRoomSize = num;\n    },\n\n\n    /**\n     * Given a 2d array (node.level), this function will split the room into two separate arrays\n     * and store then in node.lNode.level and node.rNode.level.\n     * The split is random (vertical or horizontal)\n     * and can be anywhere along the axis as long as it doesn't result in making the room smaller\n     * than this.min.\n     *\n     * @param {object} node\n     */\n    split: function split(node) {\n      var _this = this;\n\n      if (node.level.length > this.maxRoomSize || node.level[0].length > this.maxRoomSize) {\n        // If this condition is true, then we need to split again\n\n        var splitDirection = randomDirection(this.getSplitOptions(node.level.length, node.level[0].length));\n        var indexToSplit = this.getIndexToSplit(splitDirection, node.level[0].length, node.level.length);\n\n        var lNode = node.leftNode = {};\n        var rNode = node.rightNode = {};\n        node.splitDirection = splitDirection;\n        node.splitIndex = indexToSplit;\n\n        /**\n         * Split the rooms either vertically or horizontally and store the\n         * new array in the left node and right nodes\n         */\n        if (splitDirection === VERTICAL) {\n          lNode.level = node.level.map(function (row) {\n            return row.slice(0, indexToSplit);\n          });\n          rNode.level = node.level.map(function (row) {\n            return row.slice(indexToSplit, row.length);\n          });\n        } else {\n          lNode.level = node.level.slice(0, indexToSplit);\n          rNode.level = node.level.slice(indexToSplit, node.level.length);\n        }\n\n        /**\n         * Recursive call to split the rooms again if needed\n         */\n        this.split(lNode);\n        this.split(rNode);\n      } else {\n        /**\n         * If we reach this point, then we can guarantee that the room does not\n         * have any children nodes. I.e. it's the smallest leaf node\n         * counter is used so we can visually see the different rooms when the room is rendered\n         */\n        this.counter += 1;\n        node.level = node.level.map(function (row) {\n          return row.map(function () {\n            return _this.counter;\n          });\n        });\n        node.level = AddRoomBoundaries(node.level);\n      }\n    },\n\n\n    /**\n     * returns an array with the values VERTICAL if a vertical split is an option, and\n     * HORIZONTAL is a horizontal split is an option, or an empy array neither are options.\n     * Whether or not it is an option is based on if the size of the room is greater than\n     * the maximum allowed room size.\n     *\n     * @param {number} verticalLength\n     * @param {number} horizontalLength\n     * @returns {array}\n     */\n    getSplitOptions: function getSplitOptions(verticalLength, horizontalLength) {\n      var directionOptions = [];\n      if (verticalLength > this.maxRoomSize) {\n        directionOptions.push(HORIZONTAL);\n      }\n      if (horizontalLength > this.maxRoomSize) {\n        directionOptions.push(VERTICAL);\n      }\n      return directionOptions;\n    },\n\n\n    /**\n     * Returns a random number along the vertical or horizontal axis\n     *\n     * @param {any} verticalLength\n     * @param {any} horizontalLength\n     * @returns {number}\n     */\n    getIndexToSplit: function getIndexToSplit(splitDirection, horizontalLength, verticalLength) {\n      var min = this.minRoomSize;\n      var max = splitDirection === VERTICAL ? horizontalLength - min : verticalLength - min;\n      return randomIndexBetweenValues(min, max);\n    },\n\n\n    /**\n     * @param {any} node\n     * @returns\n     */\n    connectRooms: function connectRooms(node) {\n      /**\n       * First, recursively loop through all the rooms so we're starting at the\n       * lowest nodes in the tree that have child nodes, and we work our way back up.\n       */\n      if (node.leftNode) {\n        this.connectRooms(node.leftNode);\n      } else {\n        return;\n      }\n\n      if (node.rightNode) {\n        this.connectRooms(node.rightNode);\n      } else {\n        return;\n      }\n\n      var lNode = node.leftNode.level;\n      var rNode = node.rightNode.level;\n\n      /**\n       * Since this function is called after all the rooms have been created, we know that all\n       * the rooms already have boundaries. We just need to remove the wall at a random\n       * intersecting point.\n       */\n      if (node.splitDirection === VERTICAL) {\n        /**\n         * For vertical cut, the corridor will be horizontal.\n         * So somewhere along the 0 -> firstRoom.length axis\n         * Don't put the corridor on the outer most index values (0 and length - 1) because\n         * that can allow the corridor to be on the map boundary\n         */\n        var vIndex = randomIndexBetweenValues(1, lNode.length - 2);\n        node.corridorIndex = vIndex;\n        lNode[vIndex][lNode[0].length - 1] = 0;\n        lNode[vIndex][lNode[0].length - 2] = 0;\n        rNode[vIndex][0] = 0;\n        rNode[vIndex][1] = 0;\n      } else {\n        // For horizontal cut, the corridor will be vertical.\n        // So somewhere along the firstRoom[row[0]] -> firstRoom[row.length] axis\n        var hIndex = randomIndexBetweenValues(1, lNode[0].length - 2);\n        node.corridorIndex = hIndex;\n        lNode[lNode.length - 1][hIndex] = 0;\n        lNode[lNode.length - 2][hIndex] = 0;\n        rNode[0][hIndex] = 0;\n        rNode[1][hIndex] = 0;\n      }\n\n      /**\n       * Combine the child left node and right node rooms back together, and\n       * save the result in the current level node.\n       */\n      node.level = [];\n      if (node.splitDirection === VERTICAL) {\n        node.level = lNode.reduce(function (obj, val, index) {\n          var temp = [];\n          temp.push.apply(temp, _toConsumableArray(lNode[index]));\n          temp.push.apply(temp, _toConsumableArray(rNode[index]));\n          obj.push(temp);\n          return obj;\n        }, []);\n      } else {\n        var _node$level, _node$level2;\n\n        // If we get to this point, then the slice was horizontal\n        (_node$level = node.level).push.apply(_node$level, _toConsumableArray(lNode));\n        (_node$level2 = node.level).push.apply(_node$level2, _toConsumableArray(rNode));\n      }\n    }\n  };\n\n  // /**\n  //  * 50% chance of returning a 0\n  //  * 50% chance of returning a 1\n  //  *\n  //  * @returns {number} 0 or 1\n  //  */\n  // function fiftyfifty() {\n  //   return randomIndexBetweenValues(0, 1)\n  // }\n\n  var dungeon = Object.create(Dungeon);\n  dungeon.init(width, height, minRoomSize, maxRoomSize);\n  return dungeon.tree.level;\n}; // end NewDungeon\n\nif (window) window.NewDungeon = NewDungeon;\nexports.default = NewDungeon;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1bce244586403903e4f1","const VERTICAL = 'VERTICAL'\nconst HORIZONTAL = 'HORIZONTAL'\n\n/**\n * Returns a random number between min and max\n *\n * @param {number} min minimum random number to return\n * @param {number} max maximum random number to return\n * @returns {number}\n */\nfunction randomIndexBetweenValues(min, max) {\n  return Math.floor((Math.random() * ((max - min) + 1)) + min)\n}\n\n/**\n * Return a random direction of vertical or horizontal\n *\n * @returns {string} 'vertical' or 'horizontal'\n */\nfunction randomDirection(directionOptions = [VERTICAL, HORIZONTAL]) {\n  if (directionOptions.length === 0) {\n    return ''\n  }\n\n  const numOptions = directionOptions.length - 1\n  return directionOptions[randomIndexBetweenValues(0, numOptions)]\n}\n\n/**\n * Add blocking tiles around the parameter of the 2d array\n *\n * @param {array} array 2d array representing a room\n */\nfunction AddRoomBoundaries(array) {\n  const currHeight = array.length - 1\n  const currWidth = array[0].length - 1\n  return array.map((row, rIndex) =>\n    row.map((col, cIndex) => {\n      if (rIndex === 0 || rIndex === currHeight || cIndex === 0 || cIndex === currWidth) {\n        return 1\n      }\n      return col\n    }),\n  )\n}\n\n/**\n * Function used to create a new dungeon object\n *\n * @param {number} [width=50]\n * @param {number} [height=50]\n * @param {number} [minRoomSize=5]\n * @param {number} [maxRoomSize=20]\n * @returns dungeon object\n */\nconst NewDungeon = function NewDungeon(\n  { width = 50, height = 50, minRoomSize = 5, maxRoomSize = 20 },\n) {\n  const Dungeon = {\n\n    init(width, height, minRoomSize, maxRoomSize) {\n      // Create an empty 2D array width x height\n      this.minRoomSize = 5\n      this.maxRoomSize = 20\n      this.counter = 1\n\n      // What am I trying to do here?\n      this.tree = {\n        level: Array.apply(null, { length: height }).map(() => (\n          Array.apply(null, { length: width })),\n        ),\n      }\n      this.split(this.tree)\n      this.connectRooms(this.tree)\n    },\n\n\n    setMinRoomSize(num) {\n      if (num > this.maxRoomSize) {\n        throw new Error(`Minimum room size cannot be larger than the maximum room size of ${this.maxRoomSize}`)\n      }\n      this.minRoomSize = num\n    },\n\n\n    setMaxRoomSize(num) {\n      if (num < this.minRoomSize) {\n        throw new Error(`Maximum room size cannot be smaller than the minimum room size of ${this.minRoomSize}`)\n      }\n      this.minRoomSize = num\n    },\n\n\n    /**\n     * Given a 2d array (node.level), this function will split the room into two separate arrays\n     * and store then in node.lNode.level and node.rNode.level.\n     * The split is random (vertical or horizontal)\n     * and can be anywhere along the axis as long as it doesn't result in making the room smaller\n     * than this.min.\n     *\n     * @param {object} node\n     */\n    split(node) {\n      if (node.level.length > this.maxRoomSize || node.level[0].length > this.maxRoomSize) {\n        // If this condition is true, then we need to split again\n\n        const splitDirection = randomDirection(\n          this.getSplitOptions(node.level.length, node.level[0].length),\n        )\n        const indexToSplit = this.getIndexToSplit(\n          splitDirection, node.level[0].length, node.level.length,\n        )\n\n        let lNode = node.leftNode = {}\n        let rNode = node.rightNode = {}\n        node.splitDirection = splitDirection\n        node.splitIndex = indexToSplit\n\n        /**\n         * Split the rooms either vertically or horizontally and store the\n         * new array in the left node and right nodes\n         */\n        if (splitDirection === VERTICAL) {\n          lNode.level = node.level.map(row => row.slice(0, indexToSplit))\n          rNode.level = node.level.map(row => row.slice(indexToSplit, row.length))\n        } else {\n          lNode.level = node.level.slice(0, indexToSplit)\n          rNode.level = node.level.slice(indexToSplit, node.level.length)\n        }\n\n        /**\n         * Recursive call to split the rooms again if needed\n         */\n        this.split(lNode)\n        this.split(rNode)\n      } else {\n        /**\n         * If we reach this point, then we can guarantee that the room does not\n         * have any children nodes. I.e. it's the smallest leaf node\n         * counter is used so we can visually see the different rooms when the room is rendered\n         */\n        this.counter += 1\n        node.level = node.level.map(row => row.map(() => this.counter))\n        node.level = AddRoomBoundaries(node.level)\n      }\n    },\n\n    /**\n     * returns an array with the values VERTICAL if a vertical split is an option, and\n     * HORIZONTAL is a horizontal split is an option, or an empy array neither are options.\n     * Whether or not it is an option is based on if the size of the room is greater than\n     * the maximum allowed room size.\n     *\n     * @param {number} verticalLength\n     * @param {number} horizontalLength\n     * @returns {array}\n     */\n    getSplitOptions(verticalLength, horizontalLength) {\n      const directionOptions = []\n      if (verticalLength > this.maxRoomSize) {\n        directionOptions.push(HORIZONTAL)\n      }\n      if (horizontalLength > this.maxRoomSize) {\n        directionOptions.push(VERTICAL)\n      }\n      return directionOptions\n    },\n\n\n    /**\n     * Returns a random number along the vertical or horizontal axis\n     *\n     * @param {any} verticalLength\n     * @param {any} horizontalLength\n     * @returns {number}\n     */\n    getIndexToSplit(splitDirection, horizontalLength, verticalLength) {\n      const min = this.minRoomSize\n      const max = splitDirection === VERTICAL ? horizontalLength - min : verticalLength - min\n      return randomIndexBetweenValues(min, max)\n    },\n\n\n    /**\n     * @param {any} node\n     * @returns\n     */\n    connectRooms(node) {\n      /**\n       * First, recursively loop through all the rooms so we're starting at the\n       * lowest nodes in the tree that have child nodes, and we work our way back up.\n       */\n      if (node.leftNode) {\n        this.connectRooms(node.leftNode)\n      } else {\n        return\n      }\n\n      if (node.rightNode) {\n        this.connectRooms(node.rightNode)\n      } else {\n        return\n      }\n\n      const lNode = node.leftNode.level\n      const rNode = node.rightNode.level\n\n\n      /**\n       * Since this function is called after all the rooms have been created, we know that all\n       * the rooms already have boundaries. We just need to remove the wall at a random\n       * intersecting point.\n       */\n      if (node.splitDirection === VERTICAL) {\n        /**\n         * For vertical cut, the corridor will be horizontal.\n         * So somewhere along the 0 -> firstRoom.length axis\n         * Don't put the corridor on the outer most index values (0 and length - 1) because\n         * that can allow the corridor to be on the map boundary\n         */\n        const vIndex = randomIndexBetweenValues(1, lNode.length - 2)\n        node.corridorIndex = vIndex\n        lNode[vIndex][lNode[0].length - 1] = 0\n        lNode[vIndex][lNode[0].length - 2] = 0\n        rNode[vIndex][0] = 0\n        rNode[vIndex][1] = 0\n      } else {\n      // For horizontal cut, the corridor will be vertical.\n      // So somewhere along the firstRoom[row[0]] -> firstRoom[row.length] axis\n        const hIndex = randomIndexBetweenValues(1, lNode[0].length - 2)\n        node.corridorIndex = hIndex\n        lNode[lNode.length - 1][hIndex] = 0\n        lNode[lNode.length - 2][hIndex] = 0\n        rNode[0][hIndex] = 0\n        rNode[1][hIndex] = 0\n      }\n\n      /**\n       * Combine the child left node and right node rooms back together, and\n       * save the result in the current level node.\n       */\n      node.level = []\n      if (node.splitDirection === VERTICAL) {\n        node.level = lNode.reduce((obj, val, index) => {\n          const temp = []\n          temp.push(...lNode[index])\n          temp.push(...rNode[index])\n          obj.push(temp)\n          return obj\n        }, [])\n      } else {\n        // If we get to this point, then the slice was horizontal\n        node.level.push(...lNode)\n        node.level.push(...rNode)\n      }\n    },\n  }\n\n\n  // /**\n  //  * 50% chance of returning a 0\n  //  * 50% chance of returning a 1\n  //  *\n  //  * @returns {number} 0 or 1\n  //  */\n  // function fiftyfifty() {\n  //   return randomIndexBetweenValues(0, 1)\n  // }\n\n  const dungeon = Object.create(Dungeon)\n  dungeon.init(width, height, minRoomSize, maxRoomSize)\n  return dungeon.tree.level\n} // end NewDungeon\n\nif (window) window.NewDungeon = NewDungeon\nexport default NewDungeon\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}